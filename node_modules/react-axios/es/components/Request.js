function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import axios from 'axios';
import { debounce } from '../utils';

var Request = function (_React$Component) {
  _inherits(Request, _React$Component);

  function Request(props) {
    _classCallCheck(this, Request);

    var _this2 = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this2.state = {
      isLoading: false,
      response: null,
      error: null
    };
    // create debounce function
    _this2.setupDebounce(props);
    return _this2;
  }

  Request.prototype.componentWillReceiveProps = function componentWillReceiveProps(newProps) {
    if (this.props.debounce !== newProps.debounce) {
      this.setupDebounce(newProps);
    }

    // quick and dirty prop compare
    var oldPropStr = JSON.stringify(this.props);
    var newPropStr = JSON.stringify(newProps);
    if (oldPropStr != newPropStr && newProps.isReady) {
      this.debounceMakeRequest(this.getConfig(newProps));
    }
  };

  Request.prototype.componentDidMount = function componentDidMount() {
    if (this.props.isReady) {
      this.debounceMakeRequest(this.getConfig(this.props));
    }
  };

  Request.prototype.setupDebounce = function setupDebounce(props) {
    this.debounceMakeRequest = debounce(this.makeRequest, props.debounce);
  };

  Request.prototype.getConfig = function getConfig(props) {
    return Object.assign({ url: props.url, method: props.method, data: props.data }, props.config);
  };

  Request.prototype.makeRequest = function makeRequest(config) {
    var _axios = this.props.instance || this.context.axios || axios;
    // setup cancel tokens
    if (this.source) {
      this.source.cancel('Canceling previous request.');
    }
    this.source = axios.CancelToken.source();

    // set the isLoading flag
    this.setState({ isLoading: true, error: null });
    if (typeof this.props.onLoading === 'function') {
      this.props.onLoading();
    }

    // time to make the axios request
    var _this = this;
    _axios.request(Object.assign({ cancelToken: this.source.token }, config)).then(function (res) {
      _this.setState({ isLoading: false, response: res });
      if (typeof _this.props.onSuccess === 'function') {
        _this.props.onSuccess(res);
      }
    }, function (err) {
      if (!_axios.isCancel(err)) {
        _this.setState({ isLoading: false, response: null, error: err });
        if (typeof _this.props.onError === 'function') {
          _this.props.onError(err);
        }
      }
    });
  };

  Request.prototype.render = function render() {
    if (typeof this.props.children === 'function') {
      return this.props.children(this.state.error, this.state.response, this.state.isLoading);
    }
    return null;
  };

  return Request;
}(React.Component);

Request.contextTypes = {
  axios: React.PropTypes.func
};

Request.defaultProps = {
  url: '',
  method: 'get',
  data: {},
  config: {},
  debounce: 200,
  isReady: true
};

Request.propTypes = {
  instance: React.PropTypes.func,
  url: React.PropTypes.string.isRequired,
  method: React.PropTypes.string.isRequired,
  data: React.PropTypes.object,
  config: React.PropTypes.object,
  isReady: React.PropTypes.bool,
  debounce: React.PropTypes.number,
  onSuccess: React.PropTypes.func,
  onLoading: React.PropTypes.func,
  onError: React.PropTypes.func,
  children: React.PropTypes.func
};

export default Request;